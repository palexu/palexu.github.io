这个直播的问题在于，没有实战场景的演示。没有数据支撑，全都是纸面计算数字。现实场景可能遇到的问题会有很多，而这里都没有进行列举。

目录
1 业务场景与需求分析
2 架构设计与实践
3 落地实战方案

# 业务场景描述：
1. 主持人直播出题
2. 参与用户规定时间内作答
3. 打错淘汰，答对下一题
4. 最后胜者平分奖金

# 架构设计与实践
经典三层架构
1. 网关层（外部http请求转为内部rpc请求）
2. 业务逻辑层（商品、订单、用户。。。）
3. 数据访问层（屏蔽数据访问逻辑） 业务逻辑层不受数据迁移的影响

水平扩展，要求业务逻辑层无状态

# 架构设计与实践
核心业务（技术难点）：
1. 海量答题的实时处理
    时间窗口短，用户流量大
2. 被淘汰用户快速识别
    前端拦截，后端也需要处理
3. 作弊用户的识别
4. 留存与淘汰用户的计数

## 海量答题的实时处理
瞬时高流量，很像秒杀。
 因此可以用mq来平整流量。

如何给用户返回查询结果
 提供一个rpc的异步查询

如何答题判断？

业务普遍设计思路
- 问题答案redis中缓存
- 业务逻辑层判断用户答案

这个思路存在的问题：

- 调用链路长
- redis访问频繁
- 慢！

#### 答题判断方案：

##### 方案1: 前端存储问题答案

1. 前端自行判断
降低后端访问压力

问题：
安全性，被破解。  由于本来就准备了资金，因此对资金没有直接损失。但是获取的都是垃圾用户/破解用户，钱就白花了。

##### 方案2: 只能采用后端判断方案：
 让业务逻辑层带状态，答题数据放到逻辑层，在内存中处理状态。
 网关是否也可以支持业务？

核心：三层架构是一个很好的方案。但是延时、高并发业务， 可以在单应用内处理。最后又退化回了单层架构。

因此：
答题缓存在模块内存，减少redis访问。

那么怎么做扩展？
1. 提前装载，不影响扩展性
2. 接入配置中心（集中管理所有配置，实时下发，热生效）



## 识别淘汰用户

#### 方案1: 用户状态redis中存储

- redis读写压力很大
- 额外网络调用

假设500w人参加

第一题：500w人

第二题：450w人

第三题：。。。

累计（500w+x）*n/2 次总调用，量太大，扛不住。不能都存在redis里？



因此是否能uid路由到同一台机器，然后机器内存中保存用户的状态？

（不能用四层ip去路由，因为移动端设备ip可能会变；七层uid lua脚本hash也会出问题）

但是后端扩容时，hash还是会有问题。



那么，能不能考虑在前端处理呢？



#### 方案2: app记录用户状态

使用token（uid，复活币数量，复活币使用数量，答题序号，答题状态）

- 答题状态信息加密返回客户端，作为请求参数。
- 服务端校验，更新状态信息，然后再加密返回。

（app说自己答题失败，一定失败；如果说自己成功，再校验？）



复活币的使用？

- 复活币用于跳题（而不是重答题）

复活币的数量在token中保存，业务逻辑扣减复活币后更新token返回用户，然后异步扣减服务端复活币记录。



token会不会被破解？概率很低，可以认为不被破解。

- 客户端只拿公钥加密，不拿私钥。没有私钥泄露问题。
- 每场活动更换密钥。

接口会不会被破解？有可能，因此需要防作弊来识别作弊用户。

作弊体现为：重复答题

## 识别作弊用户

对于重复答题的用户

#### 方案1: 后端保存用户答题记录，每次识别用户同一题答了几次

后端流量还是很大。



可以认为作弊是小部分人的行为，

先重新理解下场景：

- 登顶平分奖金
- 不要求实时发放



（讲师认为，最后登顶100人，其中20人作弊， 最后发放可以只发80人，即奖金/80，每人多分奖金）  

>  问题在于不公平， 实际上有些人也差点登顶，被作弊的挤下去了。

#### 方案2: 不实时分析，而是异步分析作弊的人。事后识别。

。。。



## 统计用户留存

计数器： 淘汰用户，留存用户

#### 方案1:直接操作redis 来设值

对redis流量过大

重新理解场景：

是否需要精准计数？不需要， 答题数量不要求非常精确。

#### 方案2：每个节点每200次提交一次计数， 即使节点挂掉，也只丢200个值。

因此使用这个。



## 架构设计方案回顾

从标准的分层无状态业务架构 -> 有状态服务 -> 有状态聚合单体服务

又退化回了原始的结构。

架构是用于解决业务问题的， 能解决业务问题的才是好架构。



```plantUML
@startuml

autonumber

actor "用户" as User
participant "浏览器" as Browser
participant "服务端" as Server #green

activate User

User -> Browser: 输入 URL
activate Browser

Browser -> Server: 请求服务器
activate Server

Server -> Server: 模板渲染
note right of Server: 这是一个注释

Server -> Browser: 返回 HTML
deactivate Server

Browser --> User


@enduml
```
