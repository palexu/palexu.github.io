<blockquote>
  <p>“虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销，其将随着线程数量的增加很快变得明显，并且在高负载下愈演愈烈。此外，仅仅由于应用程序的整体复杂性或者并发需求，在项目的生命周期内也可能会出现其他和线程相关的问题。”</p>

  <p>摘录来自: [美] Norman Maurer Marvin Allen Wolfthal. “Netty实战。”</p>
</blockquote>

<p>与 Netty 中的 EventLoop 类似, JStorm 中也建立了一套线程模型, 用于简化创建线程的过程, 并提高性能. 其具体的实现便是 AsyncLoopThread .</p>

<h2 id="asyncloopthread">AsyncLoopThread</h2>

<p>com.alibaba.jstorm.callback.AsyncLoopThread</p>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fz9q4g0nmjj31dk0om75n.jpg" alt="" /></p>

<p>核心方法： init</p>

<p>从上面的代码段中, 可以看到 AsyncLoopThread 的启动是去调用了持有的 Runnable#start, 实际上是 JStorm 设计的一个 Runnable 的子类 AsyncLoopRunable.</p>

<p>主要功能：</p>

<ol>
  <li>封装了 Thread 的 start() 方法，对 Thread 做了一些常规的配置操作。</li>
  <li>自定义了一个 AsyncLoopDefaultKill 类, 用于自定义杀死进程的操作</li>
</ol>

<p>每一个 AsyncLoopThread 对象, 持有各自的 Runnable (实际是 AsyncLoopRunable )</p>

<h2 id="asynclooprunable">AsyncLoopRunable</h2>

<p>核心方法: run</p>

<p>在初始化时传入 RunnableCallback 对象, 业务代码写在 RunnableCallback#run 中.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//构造函数</span>
<span class="kd">public</span> <span class="nf">AsyncLoopRunnable</span><span class="o">(</span><span class="n">RunnableCallback</span> <span class="n">fn</span><span class="o">,</span> <span class="n">RunnableCallback</span> <span class="n">killFn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">killFn</span> <span class="o">=</span> <span class="n">killFn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在线程启动后, AsyncLoopRunnable 会在 while 循环中, 不断执行 fn#run, 调用业务代码逻辑.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(!</span><span class="n">shutdown</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">{</span>
    <span class="c1">//执行初始化时传入的 RunnableCallback 对象的 run 方法</span>
    <span class="n">fn</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">shutdown</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">shutdown</span><span class="o">();</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Exception</span> <span class="n">e</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="na">error</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Object</span> <span class="n">rtn</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="na">getResult</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">needQuit</span><span class="o">(</span><span class="n">rtn</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">shutdown</span><span class="o">();</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>在启动后, AsyncLoopRunable 中存在一个循环, 会不断执行 RunnableCallback#run (这个是最终的业务代码逻辑).</p>

<p>AsyncLoopThread 的使用方法如上所示: 在 新建AsyncLoopThread时, 将业务逻辑封装为一个RunableCallback对象传入.</p>

<p>这样当AsyncLoopThread启动后, 会启动一个异步( Async )的线程, 该线程会循环( Loop )执行传入的业务逻辑, 直到终止条件被触发.</p>
