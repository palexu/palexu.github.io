---
title: 走近缓存
date: '2018-02-02 21:57'
tag: '缓存'
---

> 吾常闻，非人勤以求知，乃知者勤以求人也。然吾知其谬。其知者非求人，实乃出而逐人矣。其刻深无情者，如鹰犬逐兔。

# 简介

## 为什么要使用缓存？

传统的后端业务场景中，访问量以及对响应时间的要求均不高，通常只使用DB即可满足要求。这种架构简单，便于快速部署，很多网站发展初期均考虑使用这种架构。但是随着访问量的上升，以及对响应时间的要求提升，单DB无法再满足要求。这时候通常会考虑DB拆分(sharding)、读写分离、甚至硬件升级(SSD)等以满足新的业务需求。

但是这种方式仍然会面临很多问题，主要体现在：性能提升有限，很难达到数量级上的提升，尤其在互联网业务场景下，随着网站的发展，访问量经常会面临十倍、百倍的上涨。成本高昂，为了承载N倍的访问量，通常需要N倍的机器，这个代价难以接受。

当然还有原因是没钱上全内存：）

### 每个开发者都应当知道的读写速度清单

【图】

### 存储器速度金字塔

【图】

### 二八定律

二八定律又名80/20定律、帕累托法则（定律）也叫巴莱特定律、最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。

是19世纪末20世纪初意大利经济学家巴莱多发现的。他认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。

## 日常开发中会接触到哪些缓存

常用的是本地缓存和使用一些分布式的缓存中间件。

对于单机的、数量不大的，我们常选用Map家族（如HashMap、ConcurrentHashMap），Guava Cache等。

对于分布式缓存中间件，常用的有Redis、Memcached等。

> 小知识:Buffer和Cache分别是什么，它们有什么区别？

>1、Buffer（缓冲区）是系统两端处理速度平衡（从长时间尺度上看）时使用的。
它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。

>2、Cache（缓存）则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memoryhierarchy）的策略来减小这种差异带来的影响。

## 常关注的缓存的属性

1. 命中率,它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高。
2. 最大元素,根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存。同时它也和gc、回收策略有关。
3. 缓存清空算法,影响元素回收的效率

### 缓存清空算法

主要有这些：LRU（LRU2、2Q、ARC），MRU，LFU，FIFO（Second Chance），CLOCK

# 从零实现一个本地缓存

1. 底层数据结构
2. 缓存淘汰算法

## 基本款
【图】

仅限于类的自身作用域内，类间无法共享缓存，且存在并发问题。

## 升级款
【图】
优点：
静态变量实现类间可共享，进程内可共享。

缺点：
缓存的实时性稍差。
无法gc来回收占用的堆内存。

## 自动款
【图】

使用了SoftReference。
>Java.lang.ref 是 Java 类库中特殊的一个包.
提供垃圾回收器密切相关的引用类。
这些引用类对象可以指向其它对象，但它们不同于一般的引用，因为它们的存在并不防碍 Java 垃圾回收器对它们所指向的对象进行回收。

软引用有以下特征：
1.使用 get() 方法取得对象的强引用从而访问目标对象。
2.所指向的对象按照 JVM 的使用情况（Heap 内存是否临近阈值）来决定是否回收。
3.可以避免 Heap 内存不足所导致的异常。

好处:
可以保持对使用对象的引用，同时 JVM 依然可以在内存不够用的时候对使用对象进行回收。

JVM如何对这块内存进行回收？
1.先清空它的 SoftReference，这时调用SoftReference 的 get() 方法将会返回 null
2.调用value的 finalize() 方法，并在下一轮 GC 中对其真正进行回收。


总结，以上这类缓存实现，

优点：
1. 能直接在heap区内读写
2. 快、方便

缺点：
1. 受heap区域影响，缓存的数据量有限
2. 同时缓存时间受GC影响。

主要满足单机场景下的小数据量缓存需求，同时对缓存数据的变更无需太敏感感知，如配置管理、基础静态数据等场景。

其实还有一个缺点，
不在同个虚拟机的多个进程之间，
无法对本地缓存进行实时同步。

即：同步定时任务刷新具有时效性。可以考虑通过ZK统一监听资源然后通知所有关注该资源的应用。
